<!DOCTYPE html>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-58919029-1', 'auto');
  ga('send', 'pageview');

</script>

<html>

<head>
  <meta content="text/html; charset=utf-8" http-equiv="content-type">
  <meta name="robots" content="follow" />
  
  <title>
    MK Dynamics - Computer Security - Basic Linux Exploits
  </title>
  
  <link href="../../css/styles.css" type = "text/css" rel = "stylesheet" />
  
  <style>
    .content {
	overflow: auto;
	height: 80%; 
	background: url("../../images/saturn.jpg") no-repeat center center fixed;
	background-size: cover;
	background-position: center;
	padding: 10px;
	margin: 10px;
	border: 5px solid black;
      }
      
    h1, h2, h3, h4 {
      color: white;
      display: block;     
    }
    
    h3 {
        margin-left     : 30px;
    }
    
    .current_project_1 {
        border		: 5px solid black;
        background	: gray;
        position	: relative;
        width		: 900px;
        height		: 200px;
        top		: 0px;
        left		: 0px;
        float		: left;
        margin		: 10px;
        padding-left	: 10px;
    }
    
    .current_project_2 {
        border		: 5px solid black;
        background	: gray;
        position	: relative;
        width		: 900px;
        height		: 4700px;
        top		: 000px;
        left		: 0px;
        float		: left;
        margin		: 10px;
        padding-left	: 10px;
    }
    
    .current_project_3 {
        border		: 5px solid black;
        background	: gray;
        position	: relative;
        width		: 900px;
        height		: 9000px;
        top		: 000px;
        left		: 0px;
        float		: left;
        margin		: 10px;
        padding-left	: 10px;
    }
    
    .current_project_4 {
      border		: 5px solid black;
      background	: gray;
      position		: relative;
      width		: 900px;
      height		: 20000px;
      top		: 000px;
      left		: 0px;
      float		: left;
      margin		: 10px;
      padding		: 10px;
    }
    
    .current_project_5 {
      border		: 5px solid black;
      background	: gray;
      position		: relative;
      width		: 900px;
      height		: 3600px;
      top		: 000px;
      left		: 0px;
      float		: left;
      margin		: 10px;
      padding		: 10px;
    }
    
    .current_project_6 {
      border		: 5px solid black;
      background	: gray;
      position		: relative;
      width		: 900px;
      height		: 3100px;
      top		: 000px;
      left		: 0px;
      float		: left;
      margin		: 10px;
      padding		: 10px;
    }
    
    div .img {
      margin		: 0px;
      padding		: 10px;
      height		: auto;
      width		: auto;
      float		: left;
    }
    
    div .img img {
      display		: inline;
      margin		: 0px;
      padding		: 0px;
      float             : auto;
    }
    
    div .desc {
      color		: white;
      width		: 600px;
      margin		: 5px;
      padding		: 10px;
    }
    
    table, th, td {
        padding         : 5px;
    }

    table {
        border-spacing  : 25px;
        /*border          : 1px solid black;*/
    }
    
  </style>
</head>

<body>
    <div class="wrapper">
    
        <header>
    
            <hgroup>
                <h1> 
                    <big> <big> MK Dynamics </big> </big>
                </h1>


                <h2>
                    Computer Security - Basic Linux Exploits
                </h2>
            </hgroup>
    

            <nav>
                <ul>
                    <li> <a href="../../index.html">Home</a> </li>
                    <li> <a href="computer_security.html">Back</a> </li>
                </ul>
            </nav>
  
            <hr />
    
        </header>
    
        <section class="content">
            
            <!-- ************************************************************************************** First Section Start ************ -->
            <section class="first_section">
        
                <div class="current_project_1">
                    
                    <hgroup>
                        <h3>
                            Introduction
                        </h3>
                    </hgroup>
                    

                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        
                        <p>
                            This section will borrow heavily from Gray Hat Hacking, The Ethical Hacker's Handbook, by Regaldo, et. al, McGraw Hill, 4th. Edition., as well as the classic discussion on Buffer Overflows by Aleph One.<br>
                            <a href="https://insecure.org/stf/smashstack.html">Aleph One's Classic on Buffer Overflows.</a>
                        </p>
                        
                        <p>
                            In this section, we will discuss trying to inject shellcode into a vulnerable program from the command line, investigate errors, and perform debugging of these errors with the Gnu DeBugger (GDB).
                        </p>
                    
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->

                </div> <!-- .current_project_1 -->
        
            </section> <!-- first_section -->
            <!-- ************************************************************************************** First Section End ************ -->
            
            <!-- *********************************************************************************** Second Section Start ************ -->
            <section class="second_section">
                
                <div class="current_project_2">
                
                    <hgroup>
                        <h3>
                            Smashing the Stack of a Vulnerable Program and Causing a Buffer Overflow
                        </h3>
                    </hgroup>
                    
                    <hgroup>
                        <h4>
                            Introduction to Buffer Overflows and Preparing a 32-bit Ubuntu Virtual Machine
                        </h4>
                    </hgroup>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                    
                        <p>
                            The following image was taken from the following presentation:<br><br>
                            Stack-Based Buffer Overflows Attacker<br>
                            By: Laurence Davis<br>
                            <a href="https://slideplayer.com/slide/4775349/">Stack-Based Buffer Overflows</a>
                        </p>
                        
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                     <figure>
                        <div class="img">
                            <img 
                                src="images/Basic_Linux_exploits/buffer_overflow_image.jpeg"
                                width="800"
                                height="650"
                                title=""
                            >
                        </div> <!-- .img -->
                        <div class="desc">
                            Buffer overflow corrupting return address on the stack
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            By overfilling the function's local variables with data, one is able to overwrite the saved EIP (return pointer in the figure).  This is a vulnerability in the way the kernel and C compiler handle function calls, because shellcode can be inserted onto the stack and the return address may be overwritten to point to the shellcode.  However, as seen in the section on Shellcoding, modern kernels will not allow execution of data on the stack.  So even though this vulnerability has been patched, we will still learn it because fundamentally, it is the basis for many such vulnerabilities, even in modern kernels.
                        </p>
                           
                        <p>
                            We will now investigate exploiting this vulnerability with a simple vulnerable C test program shown below.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <iframe
                        src="code/Basic_Linux_exploits/meet.c.html" 
                        height="300" 
                        width="850">
                    </iframe>
                    
                    <div class="desc">
                            The vulnerable C program: meet.c
                    </div> <!-- .desc -->
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            <a href="code/Basic_Linux_exploits/meet.c">Click here to download meet.c</a>
                        </p>
                        
                        <hgroup>
                            <h4>
                                Brief synopsis of meet.c
                            </h4>
                        </hgroup>
                        
                        <p>
                            In the program meet.c, we include string.h in order to make use of the vulnerable strcpy command.  The format of the strcpy command is as follows:<br>
                            <blockquote>char *strcpy(char *dest, const char *src);</blockquote>
                        </p>
                        
                        <p>
                            From the man page for strcpy:<br>
                            <blockquote><i>The strcpy() function copies the string pointed to by src, including the terminating null byte ('\0'), to the buffer pointed to by dest. The strings may not overlap, and the destination string dest must be large enough to receive the copy. Beware of buffer overruns!</i></blockquote>
                        </p>
                        
                        <p>
                            The program's main function reads in two arguments, which are stored in the argv array of strings.  They are argv[1] and argv[2] for the first and second arguments, respectively.
                        </p>
                        
                        <p>
                            The main function calls the function called greeting.  Greeting has a local variable that is 400 bytes long called name, which acts like a buffer.  In order to aid understanding, I have added three diagnostic statements that print out the memory addresses of the local variable name, as well as the to function arguments, temp1 and temp2.
                        </p>
                        
                        <p>
                            This is where things get interesting.  For educational purposes, the VERY vulnerable strcpy function is called from within the function greeting.  What strcpy will do is to copy the argument temp2 into the buffer name, WITHOUT any bounds checking.  This means that if the argument temp2 is carefully crafted, the buffer name can be overflowed, overwriting the main functions return address.
                        </p>
                        
                        <p>
                            The greeting function then prints out the string Hello, followed by the first argument, and the contents of the buffer.  Control is then returned back to the main functions, which prints out the string, Bye, followed by the first and second arguments from the command line.  We will now investigate attacking the built-in vulnerability in this program.  But first, we must set up the environment.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <hgroup>
                            <h4>
                                Disabling Address Space Layout Randomization (ASLR)
                            </h4>
                        </hgroup>
                        
                        <p>
                            As mentioned previously, modern Linux kernels use several strategies to overcome these vulnerabilities.  One of these strategies is known as Address Space Layout Randomization (ASLR).  Essentially, the kernel randomizes the process's address space, which includes the stack, thereby precluding the ability to brute force overwriting of the return address on the stack.  Every attempt will require injection of a new malicious address that points back to the shellcode, which is extremely difficult to guess.
                        </p>
                        
                        <p>
                            Another strategy is to simply not allow execution of data on the stack.  Since the shellcode resides entirely on the stack, execution of the shellcode will not be allowed by the kernel, and the process will crash.
                        </p>
                        
                        <p>
                            To get around such protections, for pedagogical reasons, we will disable both ASLR and allow execution of data on the stack.  This will require either recompiling the C program with executable stack or enabling executable stack at the kernel level.  In order to disable ASLR, a bash shell may be opened with the following command:<br><br>
                            
                            $ setarch i386 -R /bin/bash<br><br>
                            
                            or disabling ASLR at the kernel level.  To minimize variables, it is better to do this at the kernel level; however, this is not a good idea on your main system for security reasons.  Therefore, we will spin up a 32-bit Ubuntu virtual machine and disable these protections at the kernel level, as shown in the image below:
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <figure>
                        <div class="img">
                            <img 
                                src="images/Basic_Linux_exploits/setting_up_32bit_vm.jpg"
                                width="750"
                                height="500"
                                title=""
                            >
                        </div> <!-- .img -->
                        <div class="desc">
                            Disabling ASLR in the 32-bit Ubuntu Virtual Machine
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            As can be seen from the screenshot above, it is not directly possible to disable non-executable stack or data execution protections, also called NX.  This must be done at the UEFI or BIOS level.  It is however, possible to disable ASLR by using the command:<br><br>
                            
                            $ echo "0"> /proc/sys/kernel/randomize_va_space<br><br>
                            
                            In order test that the process' address space is not randomized, we issue the following command a few times and observe that the address space is constant between issuing the command: <br><br>
                            
                            $ cat /proc/self/maps<br>
                                [.... memory layout table ....]<br><br>
                            
                            $ cat /proc/self/maps<br>
                                [.... unchanged memory layout table ....]<br><br>
                            
                            $ cat /proc/self/maps<br>
                                [.... unchanged memory layout table ....]<br><br>
                        </p>
                        
                        <p>
                            The following screenshot shows these command in the 32-bit Ubuntu VM:
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <figure>
                        <div class="img">
                            <img 
                            src="images/Basic_Linux_exploits/VM_mem_map_info_ASLR_off.jpg"
                            width="800"
                            height="550"
                            title=""
                            >
                        </div> <!-- .img -->
                        <div class="desc">
                            Process memory map showing no randomization of address space layout
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            As can be seen from the above screenshot, the address space layout is not randomized.  Each invocation of the cat /proc/self/maps command produces the same results.  Of particular interest is that the stack's address remains constant at:<br>
                            
                            <blockquote>bffdf000-c0000000 rw-p 00000000 00:00 0 [stack]</blockquote>
                        
                            Notice that the stack has permissions of rw, but not exectute.
                        </p>
                        
                        <p>
                            In order to overcome the inability to disable non-executable (NX) stack or data segments at the kernel level, we will have to remember to issue special directives to the compiler when compiling the vulnerable programs.  These compiler directives are:<br>
                            <blockquote>gcc ...<i>-zexecstack -fno-stack-protector</i>...</blockquote>
                        </p>
                        
                        <p>
                            The directive <i>-zexecstack</i> tells the compiler to enable an executable stack, while the directive <i>-fno-stack-protector</i> tells the compiler to disable stack corruption protections.
                        </p>
                        
                        <p>
                            We are now ready to attempt to overflow the buffer of the vulnerable program from the command line.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                </div> <!-- .current_project_2 -->
            
            </section> <!-- second_section -->
            <!-- ************************************************************************************* Second Section End ************ -->
        
            <!-- ************************************************************************************* Third Section Start *********** -->
            <section class="third_section">
        
                <div class="current_project_3">
            
                    <hgroup>
                        <h2>
                            Smashing the Stack of a Vulnerable Program and Causing a Buffer Overflow - Overflowing the Buffer of the Vulnerable Program meet.c
                        </h2>
                        
                        <h3>
                            Compiling meet.c with NX disabled, debugging information and statically
                        </h3>
                    </hgroup>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            As described in the previous section, it is first necessary to compile meet.c with executable stack protections off.  We will also include lots of debugging information, and we will compile the program with the <i>-static</i> flag, so that all of the called system libraries will be included in the executable.  Having all of the called system libraries included tends to aid debugging, since the GNU Debugger (GDB) will not have to jump around memory so much.  Finally, we will force 32-bit compilation.  Since we will be running the executable on a 32-bit Virtual Machine (VM), this might be a moot point, but we will do it anyway to minimize differences in executable operation among different systems.
                        </p>
                        
                        <p>
                            To compile meet.c, we issue the following command:<br>
                            
                            <blockquote>$ gcc -m32 -static -ggdb3 -zexecstack -fno-stack-protector -mpreferred-stack-boundary=2 meet.c -o meet</blockquote>
                            
                            The results of this command is shown in the image below:
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->

                    <figure>
                        <div class="img">
                            <img 
                            src="images/Basic_Linux_exploits/compiling_meet_c_in_VM.jpg"
                            width="800"
                            height="550"
                            title=""
                            >
                        </div> <!-- .img -->
                        <div class="desc">
                            Compiling meet.c statically, with NX disabled and extensive debugging information
                        </div> <!-- .desc -->
                    </figure>
                    
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            The command we used to compile meet.c had the following arguments:
                                <table style="width:100%">
                                    <tr>
                                        <th width="30%">Argument</th>
                                        <th width="70%">Meaning</th> 
                                    </tr>
                                    <tr>
                                        <td>-m32</td>
                                        <td>Compile into 32-bit mode</td>
                                    </tr>
                                    <tr>
                                        <td>-static</td>
                                        <td>Compile the program statically, with all libraries included within executable</td>
                                    </tr>
                                    <tr>
                                        <td>-ggdb3</td>
                                        <td>Include maximum debugging info</td>
                                    </tr>
                                    <tr>
                                        <td>-zexecstack</td>
                                        <td>Allow an executable stack.  Basically one part in overiding NX</td>
                                    </tr>
                                    <tr>
                                        <td>-fno-stack-protector</td>
                                        <td>Disable stack corruption protections. Second part in overiding NX</td>
                                    </tr>
                                    <tr>
                                        <td>-mpreferred-stack-boundary=2</td>
                                        <td>Sets the size of each entry in the stack to 2^2=4 bytes long.  This makes it easier four our data alignment purposes, since we will be dealing with 32-bit or 4 byte memory locations.</td>
                                    </tr>
                                </table>
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <hgroup>
                        <h3>
                            Running the executable <i>meet</i> normally
                        </h3>
                    </hgroup>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            We run the program <i>meet</i> normally with the arguments Mr Mark as follows:<br>
                            <blockquote>$ ./meet Mr Mark</blockquote>
                        </p>
                        
                        <p>
                            After issuing the command, we get the following output:
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <figure>
                        <div class="img">
                            <img 
                            src="images/Basic_Linux_exploits/running_meet_normally.jpg"
                            width="800"
                            height="600"
                            title=""
                            >
                        </div> <!-- .img -->
                        <div class="desc">
                            Running the executable meet normally with the arguments Mr Mark
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            As can be seen from the above screen capture, the program prints out the memory addresses of the buffer we will overflow, which is the 400 byte buffer called name.  It also prints out the memory addresses of the two arguments, temp1 and temp2.  The astute observer will notice that these addresses are actually in the stack segment!  Notice also that temp2 is exactly 4 bytes away from temp1.
                        </p>
                        
                        <p>
                            The program then prints out the string Hello, followed by the program arguments.  Finally, the program prints out the string Bye, followed by the program arguments.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    
                    <hgroup>
                        <h3>
                           Fuzzing the inputs to the executable <i>meet</i>
                        </h3>
                    </hgroup>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            To find the size of the buffer, we will increase the number of bytes input into the second argument until the program begins to crash.  Actually, we could have tried the first argument, but we would have found that the first argument is very resilient, since it is not actually taking part in the vulnerable strcpy command.  This could have been surmised from reverse engineering the binary, if the source code was not available.  Below we show what happens even when we inject 500 "A"'s into the first argument.  In the second image, we will attempt to insert 2000 "A"'s and see what happens.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <figure>
                        <div class="img">
                            <img 
                            src="images/Basic_Linux_exploits/fuzzing_first_arg_to_meet_c.jpg"
                            width="800"
                            height="600"
                            title=""
                            >
                        </div> <!-- .img -->
                        <div class="desc">
                            Attempt at fuzzing first argument with 500 "A"'s into the executable <i>meet</i>
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                           In the figure above, we first try 10 "A"'s and then 500 "A"'s, and nothing seems to break.  Again, this is because only the second argument participates in the vulnerable strcpy command.  To make absolutely sure, in the figure below, we inject 2000 "A"'s into the first argument of the executable <i>meet</i>.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <figure>
                        <div class="img">
                            <img 
                            src="images/Basic_Linux_exploits/fuzzing_first_arg_to_meet_c_with_2000_A.jpg"
                            width="800"
                            height="700"
                            title=""
                            >
                        </div> <!-- .img -->
                        <div class="desc">
                            Attempt at fuzzing first argument with 2000 "A"'s into the executable <i>meet</i>
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                           In the figure above, nothing seems to break.  We therefore focus on the second argument.  Our goal is to find the size of the vulnerable buffer, so we start low and work our way up until we encounter a segmentation fault.  This fault will indicate that our input has overwritten the return address of the the main function of the executable <i>meet</i>.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <figure>
                        <div class="img">
                            <img 
                            src="images/Basic_Linux_exploits/fuzzing_second_arg_to_meet_c.jpg"
                            width="800"
                            height="700"
                            title=""
                            >
                        </div> <!-- .img -->
                        <div class="desc">
                            Attempt at fuzzing second argument with increasing number of "A"'s into the executable <i>meet</i>
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            Still no segmentation faults.  We continue increasing the number of "A"'s in the figure below.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <figure>
                        <div class="img">
                            <img 
                            src="images/Basic_Linux_exploits/fuzzing_second_arg_to_meet_c_to_get_seg_fault.jpg"
                            width="800"
                            height="700"
                            title=""
                            >
                        </div> <!-- .img -->
                        <div class="desc">
                            Segmentation fault found!
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            We can see that we have found the segmentation fault after injecting 400 "A"'s into the second argument.  398 and 399 did not do it.  From this we can surmise that the first argument "Mr" took two bytes and the second argument took 400 bytes, and this was enough to overwrite the main function's return address.  Since the saved base pointer took four bytes and the saved return address took an additional four bytes, we have probably overwritten the saved base pointer, at which the main function used its stack frame operations.  But since we have corrupted the saved base pointer, the program tried to access an invalid part of memory, and hence we obtained the segmentation fault.
                        </p>
                        
                        <p>
                            From this we can surmise that the buffer size is about 400 bytes.  Let us fire up the Gnu DeBugger on the segmentation fault and see what happened.  Before we do this, we install the PEDA extension for GDB to make life easier.  This can be found at:<br>
                            <a href="https://github.com/longld/peda">Python Exploit Development Assistance</a>
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <figure>
                        <div class="img">
                            <img 
                                src="images/Basic_Linux_exploits/finding_assembly_inst_that_caused_seg_fault.jpg"
                                width="800"
                                height="700"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Finding root cause of the segmentation fault
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            We can see from GDB that the exact instruction that caused the segmentation fault was found at the address main+35:
                            <iframe
                                src="code/Basic_Linux_exploits/GDB_output_instruction_that_causes_seg_fault.txt.html" 
                                height="190" 
                                width="800">
                            </iframe>
                        </p>
                        
                        <p>
                            The instruction attempted to load into EDX the contents of the memory address pointed to by EAX.  We can observe that the contents of the registers was:
                            <iframe
                                src="code/Basic_Linux_exploits/contents_registers_at_segmentation_fault.txt.html" 
                                height="220" 
                                width="800">
                            </iframe>
                        </p>
                        
                        <p>
                            Looking specifically at EAX, it contained 0x41414149.  0x41 is the ASCII code for the capital A.  We can see that when the CPU tried to access the contents of the memory location pointed to by EAX, we got the segmentation fault.  This is because the address 0x41414149 is outside of the program's allowable access segments.
                        </p>
                        
                        <p>
                            What appears to have happened is that the return address was not overwritten, because the program was able to return to main.  However, it appears that argc and argv where overwritten by the buffer overflow.  Recall that argc contains the number of arguments, including the command itself.  In our case, argc would have been 2, since it starts at 0.
                        </p>
                        
                        <p>
                            argv[ ] is an array of strings.  Each string in argv are the arguments, where argv[0] is the command itself.  In our case, argv[1] would have been "Mr" and argv[2] would have been 400 "A"'s.  What we are really after is to overwrite EIP.  To do that, we will have to add an additional 8 "A"s, which equals a total of 8 bytes.  4 of those bytes will overwrite the saved EBP, and the other 4 bytes will overwrite the saved EIP.  We show the results of running meet with 408 "A"'s for the second argument in the screen shot below:
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <figure>
                        <div class="img">
                            <img 
                                src="images/Basic_Linux_exploits/fuzzing_second_arg_to_meet_to_overwrite_EIP.jpg""
                                width="800"
                                height="700"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Overwriting EIP by injecting 408 "A"'s into the second argument to the executable <i>meet</i>
                        </div> <!-- .desc -->
                    </figure>
                    
                    
                   <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            Now that we have found a way to overwrite EIP, we can basically get the processor to execute arbitrary code within the processes memory segment.  If we could insert shellcode into the second argument, and then overwrite the return address to point to the start of the shellcode, then we will cause the process to spawn a shell.  If this process was running under root privileges, then the shell will be a root shell, where we can basically control the entire system.  Let us try to do this from the command line.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                </div> <!-- .current_project_3 -->

            </section> <!-- third_section -->
            <!-- ************************************************************************************* Third Section End *********** -->
            
            <!-- ************************************************************************************* Fourth Section Start ******** -->
            <section class="fourth_section">
            
                <div class="current_project_4">
                    
                    <hgroup>
                        <h2>
                           Inserting Shellcode into a Vulnerable Processs from the Command Line to Obtain a Command Shell
                        </h2>
                    </hgroup>
                    
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            In this section, our goal is to try to insert shellcode into the vulnerable executable <i>meet</i>.  We will then do the same thing in GDB to see exactly what happens.
                        </p>
                        
                        <p>
                            We will approah this section by showing a successful attack of a vulnerable program from the command line, and then disect every aspect of how this was achieved.  In order to show how dramatic such an attack can be, we will escalate the privileges of the vulnerable program to that of SUID, to enable the vulnerable to drop out of normal execution and into a command shell with root privileges.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->

                    <figure>
                        <div class="img">
                            <img 
                                src="images/Basic_Linux_exploits/changing_meet_to_suid.jpg"
                                width="800"
                                height="700"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Changing the execution privileges of the executable <i>meet</i> to SUID
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            By issuing the command:
                            <blockquote>$ sudo chmod u+s meet</blockquote>
                            we give the executable <i>meet</i> the privileges to execute at the root level.  We then inject our attack payload into the second parameter, because as discussed previously, the first parameter is not vulnerable to this attack.  The attack and results are shown below:
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <figure>
                        <div class="img">
                            <img 
                                src="images/Basic_Linux_exploits/cmd_line_sc_injection_root_shell.jpg"
                                width="800"
                                height="700"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Injecting payload into the vulnerable parameter of the executable <i>meet</i> to obtain a root shell
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            SUCCESS!<br>
                            <br>
                            By issuing the command:
                            <blockquote>$ sudo ./meet mr "$(perl -e 'print "\x90"x200'; cat sc; perl -e 'print "\x90"x27' ;perl -e 'print "\x18\xf2\xff\xbf"x38')"</blockquote>
                        </p>
                            
                        <p>
                            we were able to overflow a buffer within <i>meet</i>, overwrite the return address and by doing so hijack the instruction pointer EIP to execute arbitrary code.  In this case, the arbitrary code was shellcode, which provides a command shell.  Once the shell is spawned, any command can be entered into the system at the root privilege level.
                        </p>
                        
                        <p>
                            We will now break down the attack string in great detail.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <hr>
                    
                    <hgroup>
                        <h2>
                            Breaking Down the Attack String in Detail
                        </h2>
                        
                        <h3>
                            Use of the "$(<i>cmd</i>; <i>cmd</i>; <i>cmd</i>; <i>cmd</i>)" format
                        </h3>
                    </hgroup>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            The attack string used the format:
                            <blockquote>"$(<i>cmd</i>; <i>cmd</i>; <i>cmd</i>; <i>cmd</i>)"</blockquote>
                        </p>
                        
                        <p>
                            The shell command format $() replaces the unweildy backtick " ` " format, making an entered command much easier to read and understand.  Individual commands within the parenthesis can be separated by a semicolon.  The quotation marks on the outside, i.e. "$()" tell the command shell to treat everything within the quotes as a literal string.  See below for an example:
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <figure>
                        <div class="img">
                            <img 
                                src="images/Basic_Linux_exploits/using_quotes_on_command_line.jpg"
                                width="800"
                                height="350"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Demonstration of the effect of quotation marks at the Linux command prompt
                        </div> <!-- .desc -->
                    </figure>
                    
                     <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            As can be seen from the above screen shot, putting separated commands into quotes causes everything contained within the quotes to be treated as a single string.  This is a good property for injecting shellcode from the command line into a vulnerable executable.
                        </p>
                        
                        <p>
                            We will now examine using $() and "$()" on the command line.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <figure>
                        <div class="img">
                            <img 
                                src="images/Basic_Linux_exploits/using_dollar_paranthesis_on_command_line.jpg"
                                width="800"
                                height="350"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Using $() and "$()" on command line
                        </div> <!-- .desc -->
                    </figure>
                    

                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            As can be seen from the screenshot above, putting commands separated by a semicolon within $(), causes the the output of the commands to be substituted into their place and the output to be executed by the shell.  In the case of the first command <i>date</i>, the output is Sun, for Sunday, and the shell tries to execute Sun, but this is not a valid Linux command, so the command shell throws an error.
                        </p>
                        
                        <p>
                            Alternatively, putting multiple commands separated by a semicolon within "$()" causes all of the commands to be executed, and the outputs of all of the commands are subsituted in, wherein the shell tries to execute the outputs as if they were an actual shell command.  That is why the shell returns an error in the screenshot above.
                        </p>
                        
                        <p>
                            We will now put these concepts together to craft an attack string.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <hgroup>
                        <h3>
                            Using "$()" to craft an attack string
                        </h3>
                    </hgroup>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            We begin by using to shell commands:<br>
                            
                            <blockquote>
                                perl -e '<i>perl command</i>'<br><br>
                                xxd <i>filename</i>
                            </blockquote>
                        </p>
                        
                        <p>
                            These commands can be broken down as follows:
                            
                            <table style="width:100%">
                                <tr>
                                    <th width="30%">Command</th>
                                    <th width="70%">Meaning</th> 
                                </tr>
                                <tr>
                                    <td>perl -e '<i>perl command</i>'</td>
                                    <td>Execute perl command contained within the single quotes</td>
                                </tr>
                                <tr>
                                    <td>xxd <i>filename</i></td>
                                    <td>Creates  a hex dump of a given file or standard input.</td>
                                </tr>
                            </table>
                        </p>
                        
                        <p>
                            We will craft an attack string using perl commands and pipe the output of the attack string into xxd, to see whether the hexadecimal values align properly in memory and do not contain any bad characters, such a null byte, i.e. \x00, or the linefeed character, i.e. \x0a.  The null byte is bad because many string processing functions in C interpret the null byte as the end of the string.  So if our attack string contains a null byte in the middle of it, then only a portion of the attack string will enter the vulnerable function.  This will cause the attack string to fail.  Likewise, the linefeed character will cause the parsing units of the string manipulation functions to interpret the linefeed as a user hitting the enter key.  This will again cause premature failure of the attack string.
                        </p>
                        
                        <p>
                            Let us try a simple example, such as:
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <figure>
                        <div class="img">
                            <img 
                                src="images/Basic_Linux_exploits/example_piping_into_xxd.jpg"
                                width="800"
                                height="350"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Example of piping data into xxd to observe the hexadecimal values of the characters
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            In the above screenshot, we use the echo command to take the entire output of the commands within the "$()" and echo it to the screen.  However, since we are using the unix pipe, the output is instead piped to the xxd command, which displays the hexadecimal values of the characters.  Notice that there is a problem right at the end.  There is a 0x0a character, which is the linefeed that the echo command affixes to the end.  To suppress this trailing linefeed, the -n switch is used with the echo command.  In the second issueance of the echo command, the trailing linefeed is suppressed, and we get a nice collection of hexadecimal values to fill 64 spots.
                        </p>
                        
                        <p>
                            We can now move forward with constructing the attack string.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <hr>
                    
                    <hgroup>
                        <h2>
                            Putting it all together
                        </h2>
                    </hgroup>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            Recall that the attack string was:
                            <blockquote>$ sudo ./meet mr "$(perl -e 'print "\x90"x200'; cat sc; perl -e 'print "\x90"x27' ;perl -e 'print "\x18\xf2\xff\xbf"x38')"</blockquote>
                        </p>
                        
                        <p>
                            We will focus on everything contained within the "$()" by piping it into xxd and seeing what we are actually putting into the vulnerable buffer.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <figure>
                        <div class="img">
                            <img 
                                src="images/Basic_Linux_exploits/piping_attack_string_into_xxd.jpg"
                                width="800"
                                height="350"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Piping the attack string into xxd
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            From the above screenshot, we can see that the attack string contains a prologue of 0x90 characters.  The 0x90 is the hexadecimal value of the opcode for No OPeration, or the NOP.  Since the CPU can not distingush data from executable code, the CPU begins executing the <i>data</i> as if it were <i>code</i>.  This prologue of NOP instructions is called a NOP sled, since the CPU's instruction pointer needs to be made to fall anywhere within this region, so that it will begin sliding down the NOP sled and eventually hit the shellcode, which we have highlighted by selecting it.  The shellcode was developed within another section of this website and can be found here:<br><br>
                            <a href=shellcode_generation_and_testing.html>Shellcode Generation</a>
                        </p>
                        
                        <p>
                            How can we make the CPU's instruction pointer point to somewhere in the NOP sled?  This is where real hacking skill comes in.  After the NOP sled and shellcode, we need to overflow the rest of the buffer with the memory address <i>of the buffer</i>.
                        </p>
                        
                        <p>
                            From where do we get this address?  In our case, we have access to the source code and debugging information.  Without the source code and debugging information, we would need to engage in reverse engineering of the executable.  This is not impossible, but obviously much harder to do.  For our purposes here, we will work on the easier case of knowing the exact memory address of the buffer we wish to overflow.
                        </p>
                        
                        <p>
                            In our easier case, there are two ways of finding out the memory address of the buffer we wish to overflow.<br>
                            <ul>
                                <li>Modifiying the source code to print out the memory address of the buffer.</li>
                                <li>Using the debugger GDB to find out the memory address of the buffer.</li>
                            </ul>
                        </p>
                        
                        <p>
                            This may seem to easy to many of you, and indeed it is.  So we will also explore trying to oerflow the buffer when knowing only the location of the stack pointer.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <hr>
                    
                    <hgroup>
                        <h2>
                            Discovering the memory address of the buffer we wish to overflow
                        </h2>
                    </hgroup>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            We know explore how to discover the memory address of the buffer we wish to overflow.  Recall that when running the vulnerable executable <i>meet</i> with normal inputs, we obtain the following output:
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <figure>
                        <div class="img">
                            <img 
                                src="images/Basic_Linux_exploits/running_meet_normally.jpg"
                                width="800"
                                height="350"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Discovering the memory address of the buffer we want to overflow.  The buffer is called "name".
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            We can see from the above screenshot that the memory address of the buffer that we want to overflow is:
                            <blockquote>The address of the name array is: 0xbfffee28</blockquote>
                        </p>
                        
                        <p>
                            The memory address 0xbfffee28 is what we need to fill up the rest of the buffer with, after the shellcode.  By doing so, when the CPU reaches the <i>ret</i> assembly instruction as it leaves the called function <i>greeting</i>, it will load the instruction pointer with the memory address of the overflowed buffer, and then begin execution of the instructions there.  Those instructions are the NOP sled, followed by our shellcode.
                        </p>
                        
                        <p>
                            This address needs to be four byte aligned and input into the attack string in reverse order, since memory in IA32 is written in Little-Endian format.  So in the case of 0xbfffee28, we would write it as \x28\xee\xff\xbf.
                        </p>
                        
                        <p>
                            Note that this address may change slightly with each execution of the program <i>meet</i>; therefore, some persistance is necessary when attacking from the command line.  We will now explore using the debugger GDB for finding out the address of the buffer we want to overflow.  Refer to the screenshot below:
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <figure>
                        <div class="img">
                            <img 
                                src="images/Basic_Linux_exploits/finding_the_mem_address_of_name_GEF.jpg"
                                width="800"
                                height="800"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Discovering the memory address of the buffer we want to overflow.  The buffer is called "name".
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            We can see from the GEF User Interface (UI) to GDB that we are at the vulnerable strcpy function:
                            <blockquote>strcpy (name, temp2);                       // copy the function argumemt to name
                            </blockquote>
                        </p>
                        
                        <p>
                            By the C calling convention, arguments passed to a function are pushed onto the stack in reverse order.  We can see from the screenshot that the ESP+4 contains the memory address of <i>temp2</i> and at ESP we have the memory address of the local variable <i>name</i>.  In this case, the memory address is 0xbfffea58.  Note that we are looking for the memory address of the local variable <i>name</i>, NOT what the register ESP (stack pointer) points to, but rather what is at the memory address that the ESP points to.  In other words, ESP points to an address on the stack, 0xbfffea50, and at this memory address, there is stored another memory address which is 0xbfffea58.  The contents of the memory location at the address 0xbfffea58 is the value 6, which is really just a random value, since the local variable <i>name</i> is uninitialized.
                        </p>
                        
                        <p>
                            To confirm these statements, we observe the stack after the strcpy function returns.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <figure>
                        <div class="img">
                            <img 
                                src="images/Basic_Linux_exploits/state_of_CPU_and_mem_after_strcpy_GEF.jpg"
                                width="800"
                                height="800"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            State of CPU registers, stack and relevant memory addresses after the strcpy command.
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        
                        <p>
                            We can see from the above screen shot that the passed argument temp2, at stack memory location 0xbfffea54, has been copied to stack location 0xbfffea50.  These correspond to ESP + 4 and ESP respectively. 
                        </p>
                        
                        <p>
                            We also observe that the function strcpy returns a pointer to a character (i.e. a string), and by convention, this pointer is returned into the register EAX.  From the Linux man page for strcpy:
                            
                            <blockquote>
                                char *strcpy(char *dest, const char *src);
                            </blockquote>
                            
                            We can observe from the above screenshot that the returned value into EAX is: 0xbfffea58, which is the memory address of the local variable <i>name</i> on the stack.  This is the memory address of the buffer we need to overflow.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <hgroup>
                        <h2>
                            Calculating how many bytes we need to inject into the vulnerable buffer to overwrite the instruction pointer EIP.
                        </h2>
                    </hgroup>

                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            So how many bytes below and away from the stack pointer do we need to start our attack string?  We will need to fill up 400 bytes of the buffer called <i>name</i>.  This is the local variable in the function greeting.  Then we need 400 bytes for the argument passed to the function greeting called <i>temp2</i>, 4 bytes for the argument passed to the function greeting called <i>temp1</i>. Finally we need 4 bytes for the saved EBP.  That is a total of 808 bytes.  The next 4 bytes that we must overwrite are the saved .  See the below screenshots of the state of execution just before the saved EIP is popped off of the stack, and execution is supposed to return back to the main function in the executable <i>meet</i>.  Execution never returns to the main function, but instead the shellcode is executed. 
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <hgroup>
                        <h3>
                            State of execution just before the saved EIP is popped off of the stack, and execution is supposed to return back to the main function in the executable <i>meet</i>, according to the GEF UI for GDB.
                        </h3>
                    </hgroup>
                    
                    <figure>
                        <div class="img">
                            <img 
                                src="images/Basic_Linux_exploits/just_before_attacked_ret_popped_from_stack_GEF.jpg"
                                width="800"
                                height="800"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Stack just before return to main as per GEF.
                        </div> <!-- .desc -->
                    </figure>
                    
                    <figure>
                        <div class="img">
                            <img 
                                src="images/Basic_Linux_exploits/just_before_attacked_ret_popped_from_stack_PEDA.jpg"
                                width="800"
                                height="800"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Stack just before return to main as per PEDA
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        
                        <p>
                            We can see from the above screenshots, for both the PEDA GDB UI and the GEF GDB UI, that the memory address of the <i>name</i> local variable is: 0xbfffef3a.  However, the address of the top of the stack is different.  For GEF it is 0xbfffebec, and for PEDA it is 0xbfffec0c.  This discrepancy caused by the executable <i>meet</i> being started as two different processes, each with its own address space, one for GEF, and one for PEDA.  So we should not be surprised that the top of the stack is different on each invocation of an executable, even with address randomization turned on.  To make the calculation, we simply subtract the address of the top of the stack from the address of the buffer.  In both cases, we obtain the following calculations:
                        </p>
                            
                            <table style="width:100%">
                                <tr>
                                    <th width="20%">GDB UI Name</th>
                                    <th width="20%">Memory Address of Buffer</th>
                                    <th width="20%">Memory Address of Top of Stack</th>
                                    <th width="20%">Difference in Hex [bytes]</th>
                                    <th width="20%">Difference in Decimal [bytes]</th>
                                </tr>
                                <tr>
                                    <td align="center">GEF</td>
                                    <td align="center">0xbfffef3a</td>
                                    <td align="center">0xbfffebec</td>
                                    <td align="center">0x34e</td>
                                    <td align="center">846</td>
                                </tr>
                                <tr>
                                    <td align="center">PEDA</td>
                                    <td align="center">0xbfffef3a</td>
                                    <td align="center">0xbfffec0c</td>
                                    <td align="center">0x32e</td>
                                    <td align="center">814</td>
                                </tr>
                            </table>
                            
                            <p>
                                Stated mathematically, we have:
                                <blockquote>
                                    GEF     0xbfffef3a - 0xbfffebec = 0x34e bytes = 846 bytes<br><br>
                                    PEDA    0xbfffef3a - 0xbfffec0c = 0x32e bytes = 814 bytes
                                </blockquote>
                            </p>
                            
                            <p>
                                The astute reader will notice that we calculated the theoretical number of bytes needed to overwrite the saved EIP was 812 bytes.  However, in both cases, GEF and PEDA, we have more than 812 bytes.  The reason is that we are allowed to overwrite even through the top of the stack, as long as the saved EIP is overwritten with the address of the overflowed buffer, and this address is aligned correctly to 4 bytes.  If it is misaligned, then instead of reading 0xbfffef3a of of the stack, the CPU might read a shifted version of this.  If this happens, the CPU will jump to this shifted version of the address that we want, and will most likely halt on a segmentation fault.
                            </p>
                            
                            <p>
                                In order to verify that the attack string arranges its return addresses correctly aligned to 4 bytes, we could do a number of things.  Within GDB, we could simply issue the following command:
                            </p>
                            
                            <figure>
                                <div class="img">
                                    <img 
                                        src="images/Basic_Linux_exploits/examining_812_bytes_below_ESP.jpg"
                                        width="800"
                                        height="600"
                                        title=""
                                    >
                                </div> <!-- .img -->
                                
                                <div class="desc">
                                    Examining stack memory 812 bytes below ESP
                                </div> <!-- .desc -->
                            </figure>
                            
                            <p>
                                Referring to the screenshot above, we wanted to observe the contents of stack memory starting at ESP and going down by 812 bytes.  Notice that since the stack grows downward, we need to do the opposite operation, and <i>add</i> 812 bytes, rather than subtract.  To look at a byte, we need two hexadecimal digits; therefore, looking at 300 hexadecimal digits will show us 900 bytes.  This will enable us to see our entire attack string in stack memory, with some margin.  To accomplish this, we enter the following command:
                                
                                <blockquote>
                                    (gdb) x/300x $esp+812
                                </blockquote>
                            
                            </p>
                            
                            <p>
                                Notice from the above screenshot that there is a NULL byte just ahead of our NOP sled.  Since we are aiming for the middle of the NOP sled, this leading NULL bytes is of little consquence.  Now that we have discovered the address of the vulnerable buffer, and figured out how many bytes we need to inject into it for a successful buffer overflow, we will now look at how to discover the stack address from the command line.
                            </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <hr>
                    
                    <hgroup>
                        <h2>
                            Discovering the memory address of the stack
                        </h2>
                        
                        <h3>
                            Variations in the top of the stack with multiple attack attempts from the command line
                        </h3>
                    </hgroup>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            Before we can figure out the return address to place onto the stack so that we can successfuly overwrite the saved EIP, we need to know the current address of the stack.  This is a little bit tricky, because every time the attack is attempted, the stack address changes a little bit, even with ASLR turned off.  The reason is that Linux tries to reclaim memory after the failed attack completes, and other processes are always executing at the same time, so the stack address tends to shift around a bit, by about 500 to 1000 bytes. 
                        </p>
                        
                        <p>
                            While this is not a large range, it is enough to render the attack string useless, as it will probably crash with a segmentation fault, or the attack will simply be ignored.  This all depends on which way the top of the stack has shifted in memory.  However, command line attacks are still possible as the stack will most likely stay at the same location for a few attempted attacks.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <hr>
                    
                    <hgroup>
                        <h2>
                            Discovering the memory address of the stack
                        </h2>
                        
                        <h3>
                            A small program that displays the current state of the stack pointer
                        </h3>
                    </hgroup>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            To discover the address of the stack segment in memory, we use the program listed below
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <iframe
                        src="code/Basic_Linux_exploits/get_sp.c.html" 
                        height="178" 
                        width="800">
                    </iframe>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            The program uses inline assembly within C.  Since by convention a C program returns what is contained within EAX, by calling the function get_sp from the printf statement, we obtain what is contained within ESP.  This is indeed the stack pointer, and hence the top of the stack.
                        </p>
                        
                        <p>
                            This returned value is printed out as a memory address via the 0x%x format string.  The screenshot below will display the output of running this program.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <figure>
                        <div class="img">
                            <img 
                                src="images/Basic_Linux_exploits/running_get_sp_many_times.jpg"
                                width="800"
                                height="600"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Running get_sp many times to obtain the same memory address of the stack
                        </div> <!-- .desc -->
                    </figure>
                    
                    
                    
                </div> <!-- .current_project_4 -->
                
            </section> <!-- fourth_section -->
            <!-- ************************************************************************************* Fourth Section End ******** -->
            
            <!-- ************************************************************************************* Fifth Section Start ******* -->
            <section class="fifth_section">
        
                <div class="current_project_5">
                    
                    <hgroup>
                        <h3>
                            Lorem
                        </h3>
                        
                        <h4>
                            Lorem
                        </h4>
                    </hgroup>

                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        
                        <p>
                            Lorem
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                        
                        <iframe
                            src="code/" 
                            height="275" 
                            width="800">
                        </iframe>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            Lorem
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <hgroup>
                        <h4>
                            Lorem
                        </h4>
                    </hgroup>
                    
                    <figure>
                        <div class="img">
                            <img 
                                src="images/"
                                width="800"
                                height="350"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Lorem
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            Lorem
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <hgroup>
                        <h4>
                            Lorem
                        </h4>
                    </hgroup>
                    
                    <figure>
                        <div class="img">
                            <img 
                                src="images/"
                                width="800"
                                height="700"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Lorem
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            Lorem
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->

                    <figure>
                        <div class="img">
                            <img 
                                src="images/"
                                width="800"
                                height="500"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Lorem
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            Lorem
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <figure>
                        <div class="img">
                            <img 
                                src="images/"
                                width="800"
                                height="500"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Lorem
                        </div> <!-- .desc -->
                    </figure>

                </div> <!-- .current_project_5 -->
        
            </section> <!-- fifth_section -->
            <!-- ************************************************************************************** Fifth Section End ************ -->
        

            <!-- ************************************************************************************** Sixth Section Start ********** -->
            <section class="sixth_section">
        
                <div class="current_project_6">
                    
                    <hgroup>
                        <h3>
                            Lorem
                        </h3>
                        
                        <h4>
                            Lorem
                    </hgroup>
                    

                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        
                        <p>
                            Lorem
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                        
                    <hgroup>
                        <h4>
                            Lorem
                        </h4>
                    </hgroup>
                    
                    <figure>
                        <div class="img">
                            <img 
                                src="images/"
                                width="800"
                                height="350"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Lorem
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            Lorem
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <hgroup>
                        <h4>
                            Lorem
                        </h4>
                    </hgroup>
                    
                    <figure>
                        <div class="img">
                            <img 
                                src="images/"
                                width="800"
                                height="600"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Lorem
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            Lorem
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <hgroup>
                        <h4>
                            Lorem
                        </h4>
                    </hgroup>
                    
                    <figure>
                        <div class="img">
                            <img 
                                src="images/"
                                width="800"
                                height="700"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Lorem
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            Lorem
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->

                    <figure>
                        <div class="img">
                            <img 
                                src="images/"
                                width="800"
                                height="300"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Lorem
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            Lorem
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                </div> <!-- .current_project_6 -->
        
            </section> <!-- fifth_section -->
            <!-- ************************************************************************************** Sixth Section End ************ -->
            
        </section>	<!-- .content -->
    
    <div> <!-- .wrapper -->

  </body>

</html>

                    <iframe
                        src="code/" 
                        height="450" 
                        width="800">
                    </iframe>


                    <iframe
                        src="code/" 
                        height="450" 
                        width="800">
                    </iframe>
                    
                    <figure>
                        <div class="img">
                            <img 
                                src="images/"
                                width="800"
                                height="300"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Lorem
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            Lorem
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
