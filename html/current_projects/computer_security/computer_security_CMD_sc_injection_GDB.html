<!DOCTYPE html>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-58919029-1', 'auto');
  ga('send', 'pageview');

</script>

<html>

<head>
  <meta content="text/html; charset=utf-8" http-equiv="content-type">
  <meta name="robots" content="follow" />
  
  <title>
    MK Dynamics - Computer Security
  </title>
  
  <link href="../../css/styles.css" type = "text/css" rel = "stylesheet" />
  
  <style>
    .content {
	overflow: auto;
	height: 80%; 
	background: url("../../images/saturn.jpg") no-repeat center center fixed;
	background-size: cover;
	background-position: center;
	padding: 10px;
	margin: 10px;
	border: 5px solid black;
      }
      
    h1, h2, h3, h4 {
      color: white;
      display: block;     
    }
    
    .current_project_1 {
      border		: 5px solid black;
      background	: gray;
      position		: relative;
      width		: 900px;
      height		: 200px;
      top		: 0px;
      left		: 0px;
      float		: left;
      margin		: 10px;
      padding-left	: 10px;
    }
    
    .current_project_2 {
      border		: 5px solid black;
      background	: gray;
      position		: relative;
      width		: 900px;
      height		: 2000px;
      top		: 000px;
      left		: 0px;
      float		: left;
      margin		: 10px;
      padding-left	: 10px;
    }
    
    .current_project_3 {
      border		: 5px solid black;
      background	: gray;
      position		: relative;
      width		: 900px;
      height		: 2000px;
      top		: 000px;
      left		: 0px;
      float		: left;
      margin		: 10px;
      padding-left	: 10px;
    }
    
    .current_project_4 {
      border		: 5px solid black;
      background	: gray;
      position		: relative;
      width		: 900px;
      height		: 2600px;
      top		: 000px;
      left		: 0px;
      float		: left;
      margin		: 10px;
      padding		: 10px;
    }
    
    .current_project_5 {
      border		: 5px solid black;
      background	: gray;
      position		: relative;
      width		: 900px;
      height		: 500px;
      top		: 000px;
      left		: 0px;
      float		: left;
      margin		: 10px;
      padding		: 10px;
    }
    
    div .img {
      margin		: 0px;
      padding		: 10px;
      height		: auto;
      width		: auto;
      float		: left;
    }
    
    div .img img {
      display		: inline;
      margin		: 0px;
      padding		: 0px;
    }
    
    div .desc {
      color		: white;
      width		: 600px;
      margin		: 5px;
      padding		: 10px;
    }
  </style>
</head>

<body>
    <div class="wrapper">
    
        <header>
    
            <hgroup>
                <h1> 
                    <big> <big> MK Dynamics </big> </big>
                </h1>


                <h2>
                    Computer Security - Shellcode Injection via Command Line Debug with GDB
                </h2>
            </hgroup>
    

            <nav>
                <ul>
                    <li> <a href="../../index.html">Home</a> </li>
                    <li> <a href="computer_security.html">Back</a> </li>
                </ul>
            </nav>
  
            <hr />
    
        </header>
    
        <section class="content">
            
            <!-- ************************************************************************************** First Section Start ************ -->
            <section class="first_section">
                <hgroup>
                    <h2>
                        Description
                    </h2>
                </hgroup>
        
                <div class="current_project_1">
                    
                    <hgroup>
                        <h3>
                            Introduction
                        </h3>
                    </hgroup>
                    

                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        
                        <p>
                            This section will borrow heavily from Gray Hat Hacking, The Ethical Hacker's Handbook, by Regaldo, et. al, McGraw Hill, 4th. Edition.
                        </p>
                        
                        <p>
                            In this section, we will discuss trying to inject shellcode into a vulnerable program from the command line, investigate errors, and perform debugging of these errors with the Gnu DeBugger (GDB).
                        </p>
                    
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->

                </div> <!-- .current_project_1 -->
        
            </section> <!-- first_section -->
            <!-- ************************************************************************************** First Section End ************ -->
            
            <!-- *********************************************************************************** Second Section Start ************ -->
            <section class="second_section">
                
                <div class="current_project_2">
                
                    <hgroup>
                        <h3>
                            Shellcode Generation
                        </h3>
                    </hgroup>
                    
                    <hgroup>
                        <h4>
                            Developing Basic Shellcode in Assembly
                        </h4>
                    </hgroup>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                    
                        <p>
                            The following assembly instructions use kernel system calls to invoke the change the setreuid signature level to the highest privilege level possible, which is that of root, or user (0).  This is accomplished by invoking the setreuid(0,0) system call.  After escalating the privilege level, assembly instructions then invoke the execve system call to spawn a shell, by executing the command /bin/sh at the root priviliege level.
                        </p>
                        
                        <p>
                            System calls in Linux are invoked by first setting the appropriate values into appropriate CPU registers, and then sending a call to the kernel by executing the int 0x80 instruction.  In the case of setreuid, the least significant bits of EAX, which are alternatively called AL, are set to the hex value 0x46.  To ensure that the most significant bits of EAX do not have any information in them that will invalidate the system call, the entire EAX register is first cleared by xor'ing EAX with itself.
                        </p>
                        
                        <p>
                            Subesquently, the regsters EBX and ECX contain the real user ID (ruid), and the effective user id (euid), respectfully.  Since we want ruid and euid to both be 0, or the privilege level of root, we clear them both by xor'ing them with themselves.  It is important to use the xor reg, reg instruction to clear, rather than mov 0, reg, because we want to avoid any nulls in the shellcode.  Any nulls in the shellcode will prevent vulnerable string manipulation C commands from working with the entire shellcode, since a null indicates the end of a string.
                        </p>
                        
                        <p>
                            A similar process is followed to spawn a shell.  The system call that executes commands is execve.  In order to use execve, the following format is required: evecve("/bin/sh", ["/bin/sh", NULL], NULL).  The first argument is the command to be executed, the second argument is a pointer to a string array (i.e. the name of the string itself, which is in essence an address), and lastly, a pointer to the environment string to accompany the command.  For our purposes an environment is not needed; therefore, we simply set this last argument to null.
                        </p>
                        
                        <p>
                            To set up the execve invocation properly, we need AL to contain the system call number for execve, which is 0xb.  EBX needs to contain the memory address of /bin/sh.  ECX needs to contain a pointer to the argument array (argv[]).  EDX needs to contain a pointer to the environment array, which on our case can be a NULL, since we do not need any environment for the spawned shell.
                        </p>
                        
                        <p>
                            Obviously, there is a bit of complexity here because we are dealing with strings and their memory addresses, but we also want out shellcode to be compact.  We can make use of the stack and the fact that it is simply a data structure in memory.  First, we build up the argvp[] array.  Since the last argument is a null, we clear eax to produce a NULL and push it onto the stack.  The we then push the command string /bin//sh onto the stack in little endian format.  The extra / in the command is byte padding to line up the command in memory properly, and does not change the command.  After pushing the strings onto the stack, the stack pointer, ESP, contains the address of what is effectively the command string, which is what we require in EBX.  Therefore, we copy the stack pointer contents into EBX.  
                        </p>
                        
                        <p>
                            Now we work on a pointer to argv [].  argv[] is an array of strings, where the first string is the command /bin//sh, and the second string is a NULL.  The strings are memory addresses.  If we can get the address of the command, and the address of the NULL, we effectively have argv[].  Since the command is already on the stack and stored in EBX, to get the NULL we first push the cleared EAX and then push EBX.  The stack pointer ESP now contains the address of argv[].  We load this address into ECX as required.  the environment string is NULL, which we can simply obtain by clearing EDX.  Finally, the system call number 0xb is loaded into AL and the kernel is called with the int 0x80 instruction.  Follow the comments in the code for a instruction by instruction explanation.
                        </p>
                            
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <iframe
                        src="code/sc2.asm.html" 
                        height="450" 
                        width="800">
                    </iframe>
                    
                    <div class="desc">
                            Listing of the shellcode assembly file, named sc2.asm
                    </div> <!-- .desc -->
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            Lorem Ipsum
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <figure>
                        <div class="img">
                            <img 
                            src=""
                            width="720"
                            height="300"
                            title=""
                            >
                        </div> <!-- .img -->
                        <div class="desc">
                            Lorem Ipsum
                        </div> <!-- .desc -->
                    </figure>
                
                </div> <!-- .current_project_2 -->
            
            </section> <!-- second_section -->
            <!-- ************************************************************************************* Second Section End ************ -->
        
            <!-- ************************************************************************************* Third Section Start *********** -->
            <section class="third_section">
        
                <div class="current_project_3">
            
                    <hgroup>
                        <h3>
                            Assembling, Executing and Testing the Shellcode
                        </h3>
                        
                        <h4>
                            Assembling and Linking sc2.asm and Viewing Hex Opcodes
                        </h4>
                    </hgroup>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            sc2.asm is assembled with NASM.  The format of the object file is 32 bit Executable and Linkable Format (ELF).  The contents of the produced object file are then viewed with objdump -D.  The object file is then linked to produce an executable.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->

                    <figure>
                        <div class="img">
                            <img 
                            src="images/assembling_of_sc2.jpg"
                            width="800"
                            height="700"
                            title=""
                            >
                        </div> <!-- .img -->
                        <div class="desc">
                            sc2.asm is assembled and linked.  The hex opcodes are visible via an objdump.
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            The object file's contents are saved into a text file for future viewing.  Notice the produced hex opcodes in the left columns.  These opcodes are what we are really after, as they need to be isolated and saved into a format that can be inserted into a C program for testing.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <hgroup>
                        <h4>
                           Viewing Hex Opcodes of ELF Executable
                        </h4>
                    </hgroup>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            Once we have the executable, we can then again use objdump -d to view the hex opcodes.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <figure>
                        <div class="img">
                            <img 
                            src="images/assembling_of_sc2_2.jpg"
                            width="800"
                            height="700"
                            title=""
                            >
                        </div> <!-- .img -->
                        <div class="desc">
                            The contents of the executable is shown via an objdump.
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            Since we are really after the hex opcodes, we need a method of extracting them from the executable.  This is where the objcopy utility comes in, and is discussed in the next section.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                </div> <!-- .current_project_3 -->

            </section> <!-- third_section -->
            <!-- ************************************************************************************* Third Section End *********** -->
            
            <!-- ************************************************************************************* Fourth Section Start ******** -->
            <section class="fourth_section">
            
                <div class="current_project_4">
                    <hgroup>
                        <h3>
                            Extracting the Hex Opcodes from the Executable
                        </h3>
                        
                        <h4>
                            Using the objcopy Utility to Obtain the Hex Opcodes
                        </h4>
                    </hgroup>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            The GCC toolchain contains a utility called objcopy that can copy the hex opcodes from an executable.  The format of invoking the utility is:<br>
                            objcopy -O binary sc2 sc2.bin<br>
                            We then look at the binary file with the more utility.  It is as you can expect, garbled characters, because they are not displayable ASCII characters, but rather binary values.  The binary values correspond to the hex opcodes described earlier.
                        </p>
                        
                        <p>
                            There is another utility called hexdump, which dumps the binary values into their hexadecimal representations onto the screen as displayable values.  The format of invoking the hexdump utility is as follows:<br>
                            hexdump -v -e '"\\""x" 1/1 "%02x" ""' execve3.bin<br>
                            Notice that the formatting needs to be supplied by the user.
                        </p>
                        
                        <p>
                            Now we can finally see the hex opcodes, but they are still not usable in the sense that they are not easily inserted into a C program to test the shellcode.  For this reason, I wrote a Python script that parses the binary file and prints out the hex opcodes in a format the is easily inserted into a C test program.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->

                    <figure>
                        <div class="img">
                            <img 
                                src="images/objcopy_of_sc2.jpg"
                                width="800"
                                height="700"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Extraction of Opcodes from sc2.bin and Displaying them in Hex
                        </div> <!-- .desc -->
                    </figure>
                    
                    <hgroup>
                        <h4>
                            Python Utility to Obtain the Hex Opcodes and Format to be C Program Ready
                        </h4>
                    </hgroup>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            The following Python script was written to parse the binary file and print out the hex opcodes, 10 to a line, with the appropriate quotation marks, so that they can be easily inserted into a C test program.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <iframe
                        src="code/hex_encode_w_formatting.py.html" 
                        height="450" 
                        width="800">
                    </iframe>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            The heart of the Python script is this construction:<br>
                            print ("\\x" + "".join("{:02x}".format(byte)), end="")<br>
                            The \ is escaped to print out a slash followed by an x, which signifies a hex value to the C compiler.  The join function separates the hex values into pieces of 2 hex numbers, for a total of one bytes.  So each value represents a single byte, which is what we are after.  The format function formats the binary value on a per byte basis.
                        </p>
                        
                        <p>
                            A counter is set up to count to 10, and then a new line is created.  Quotation marks are inserted before and after the hex opcodes for easy insertion into a C test program.  Running the Python script against sc2.bin produces the following output:
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                    <hgroup>
                        <h4>
                            Running the Hex Encode with Formatting Python Script on sc2.bin
                        </h4>
                    </hgroup>
                    
                    <figure>
                        <div class="img">
                            <img 
                                src="images/hex_extract_python_script.jpg"
                                width="800"
                                height="350"
                                title=""
                            >
                        </div> <!-- .img -->
                        
                        <div class="desc">
                            Output of Hex Encode with Formatting Python Script on sc2.bin
                        </div> <!-- .desc -->
                    </figure>
                    
                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        <p>
                            As can be seen from the Python script output, the opcodes are formatted, 10 to a line, with quotation markes added.  These quotation marks are needed because the opcodes will actually be part of string within the C test program.  This is also why it is important that the shellcode does not contain any nulls, as this will prematurely terminate the shellcode.
                        </p>
                        
                        <p>
                            In the next section, we will use the formatted, extracted opcodes within a C test program to verify that we indeed get a root shell upon execution.
                        </p>
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->
                    
                </div> <!-- .current_project_4 -->
                
            </section> <!-- fourth_section -->
            <!-- ************************************************************************************* Fourth Section End ******** -->
            
             <!-- ************************************************************************************ Fifth Section Start ******* -->
            <section class="fifth_section">
                <hgroup>
                    <h2>
                        Lorem
                    </h2>
                </hgroup>
        
                <div class="current_project_5">
                    
                    <hgroup>
                        <h3>
                            Lorem
                        </h3>
                    </hgroup>
                    

                    <!-- ********************************************************************* Loose Text -->                
                    <div class="loose_text">
                        
                        <p>
                            
                        </p>
                        
                        <p>
                            
                        </p>
                    
                    </div> <!-- .loose_text -->
                    <!-- ********************************************************************* Loose Text -->

                </div> <!-- .current_project_5 -->
        
            </section> <!-- fifth_section -->
            <!-- ************************************************************************************** Fifth Section End ************ -->
        

        </section>	<!-- .content -->
    
    <div> <!-- .wrapper -->

  </body>

</html>
